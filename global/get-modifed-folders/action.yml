name: "ğŸ“ Get modified directory and sparse checkout"
description: "Retrieve all modified directory and perform a sparse checkout."


inputs:
  start_folder:
    description: '(Optional) Starting index for path filtering'
    default: '/'
  default_end_folder_depth:
    description: '(Optional) Default end index for path slicing'
    default: "2"
  include_patterns:
    description: '(Required) Patterns to include in path filtering, comma separated'
    required: true
  ignore_patterns:
    description: '(Optional) Whether to exclude ignored paths'
    default: ".github,.devops,.vscode"


outputs:
  modified_paths:
    description: "List of modified paths"
    value: ${{ steps.get-paths.outputs.modified_paths }}
  dir_changes_detected:
    description: "Determines if static analysis should run"
    value: ${{ env.dir_changes_detected }}


runs:
  using: "composite"
  steps:
    - name: â¬ Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install necessary packages
      shell: bash
      run: python -m pip install --upgrade pip

    - name: ğŸ”¨ Get Modified Paths
      id: get-paths
      shell: bash
      run: |
        python - <<'EOF'
        import os
        import subprocess
        from typing import List
        import re
        import mimetypes

        DEFAULT_IGNORED_PATHS = "${{ inputs.ignore_patterns }}".split(",")

        STARTING_INDEX = "${{ inputs.start_folder }}"
        DEFAULT_END_INDEX = ${{ inputs.default_end_folder_depth }}
        INCLUDE_PATTERNS = "${{ inputs.include_patterns }}".split(",")


        def get_current_branch():
          result = subprocess.run(["git", "rev-parse", "--abbrev-ref", "HEAD"],
                                  capture_output=True, text=True)
          return result.stdout.strip()


        def get_git_diff(current_branch):
          print("ğŸ“Š Starting get_git_diff function")
          print(f"ğŸ”„ Fetching changes from origin...")
          subprocess.run(["git", "fetch", "origin"])
          print(f"âš¡ Computing diff between {current_branch} and origin/main")
          result = subprocess.run(
            ["git", "diff", "--name-only", current_branch, "origin/main"],
            capture_output=True, text=True)
          with open('/tmp/diff.txt', 'w') as f:
            f.write(result.stdout)
          print(f"ğŸ“„ Saving diff to temporary file")


        def file_check(parts):
          # Check if the last component of the path is a file and pop it if so
          if os.path.splitext(parts[-1])[1]:  # Check if the last part has an extension
            parts.pop()
          return parts

        def get_required_path(path, patterns: List):
          parts = path.split(os.sep)
          print(f"ğŸ“‚ Path components: {parts}")

          if path.startswith('../'):
            print("âš ï¸ Path starts with '../', skipping...")
            return ""

          try:
            if not any(pattern in parts for pattern in patterns):
              print("ğŸ” No matching pattern found in path components")
              if "/" in INCLUDE_PATTERNS:
                return os.sep.join(file_check(parts)[0:DEFAULT_END_INDEX])
              return ""

            for pattern in patterns:
              if pattern not in parts:
                print(f"â­ï¸ Pattern '{pattern}' not found in path, continuing...")
                continue
              print(f"âœ… Found matching pattern: {pattern}")
              start_index = parts.index(STARTING_INDEX) if STARTING_INDEX != "/" else 0
              print(f"ğŸ“Œ Start index: {start_index}")

              pattern_index = parts.index(pattern, start_index)
              print(f"ğŸ¯ Pattern index: {pattern_index}")

              if len(parts) > pattern_index + 2:
                end_index = DEFAULT_END_INDEX
                print(f"ğŸ“ Using end index: {end_index}")
                return os.sep.join(file_check(parts)[pattern_index:end_index])
              else:
                print("ğŸ“ Path too short, using full remaining path")
                return os.sep.join(file_check(parts)[pattern_index:])
          except (ValueError, IndexError) as e:
            print(f"âŒ Error in get_required_path: {e}")
            return ""

        def inspect_for_source_dependence(paths):
          local_import_paths = []
          for path in paths:
            print(f"ğŸ“‚ Inspecting path: {path}")
            # Check if path is a directory
            if not os.path.isdir(path):
              print(f"â© Skipping: {path} - Not a directory")
              continue

            for file in os.listdir(path):
              try:
                file_path = os.path.join(path, file)
                print(f"ğŸ“„ Processing file: {file_path}")
                # Skip if file is a directory
                if os.path.isdir(file_path):
                  print(f"â© Skipping directory: {file_path}")
                  continue
                # Skip binary files by checking their MIME type
                mime_type, _ = mimetypes.guess_type(file_path)
                if mime_type and not mime_type.startswith("text"):
                  print(f"â© Ignored binary file: {file_path}")
                  continue

                print(f"ğŸ“– Reading file: {file_path}")
                with open(file_path, 'r', encoding='utf-8') as file_reader:
                  for line in file_reader:
                    # Regex to match local source paths
                    local_import_pattern = r'source\s*=\s*["\'](\./|file://|\.\./)([^"\']*)["\']'
                    match = re.search(local_import_pattern, line)
                    if match:
                      full_path = match.group(2)
                      print(f"ğŸ”— Found local import: {full_path}")
                      local_import_paths.append(full_path)
              except (IsADirectoryError, UnicodeDecodeError) as e:
                print(f"âŒ Error processing file {file_path}: {e}")
                continue

        def get_modified_paths(patterns: List):
          with open('/tmp/diff.txt') as f:
            lines = f.readlines()
          print(f"ğŸ“– Reading {len(lines)} lines from diff file")

          paths = [
            line.strip()
            for line in lines
            if not any(ignored in line for ignored in DEFAULT_IGNORED_PATHS)
          ]
          print(f"ğŸš« Filtered out paths containing ignored patterns: {DEFAULT_IGNORED_PATHS}")

          valid_paths = []
          for path in paths:
            if path not in valid_paths:
              valid_paths.append(path)

          print(f"ğŸ“‹ Processing {len(valid_paths)} valid paths")
          
          # Removing duplicates and sorting
          unique_paths = sorted(set([
            get_required_path(path, patterns)
            for path in valid_paths if path
          ]))

          # Filter out empty strings and ensure unique paths
          unique_paths = list(filter(None, unique_paths))

          print("ğŸ” Checking for source dependencies...")
          unique_paths.extend(inspect_for_source_dependence(unique_paths))
          final_paths = list(dict.fromkeys(unique_paths))
          final_paths = [path for path in final_paths if not path.startswith('../')]
          print(f"âœ… Final number of paths to process: {len(final_paths)}")
          return final_paths

        def write_to_file(content, filepath):
          with open(filepath, 'w') as f:
            f.write(content)


        def main():
          print("ğŸš€ Starting main execution")
          current_branch = get_current_branch()

          print(f"ğŸŒ³ Working on branch: {current_branch}")
          get_git_diff(current_branch)

          # Combine the results of the two calls into a single list
          print("ğŸ“Š Getting modified paths...")
          modified_paths = get_modified_paths(INCLUDE_PATTERNS)

          # Join all modified paths into a single string separated by new lines
          modified_paths_str = "\n".join(modified_paths)

          # Print the results
          print(f"ğŸ“ Modified paths:\n{modified_paths_str}")
          write_to_file(modified_paths_str, "/tmp/paths.txt")
          print("ğŸ’¾ Paths saved to temporary file")

          if not os.getenv('GITHUB_ENV'):
            os.environ['GITHUB_ENV'] = 'dir_changes_detected=false\n'
            print("ğŸ”§ Created GITHUB_ENV environment variable")

          # Condition to accept any string (no filter applied)
          if not INCLUDE_PATTERNS or "*" in INCLUDE_PATTERNS or "/" in INCLUDE_PATTERNS:
            print("ğŸ”“ No filter patterns - accepting all paths")
            matched_paths = modified_paths_str.split("\n")
          else:
            print(f"ğŸ” Filtering paths with patterns: {INCLUDE_PATTERNS}")
            matched_paths = [
              path for path in modified_paths_str.split("\n")
              if any(pattern in path for pattern in INCLUDE_PATTERNS)
            ]

          # Process the results or execute actions on the matched paths
          if matched_paths:
            print(f"âœ… Found {len(matched_paths)} matching paths")
            with open(os.getenv('GITHUB_ENV'), 'a') as f:
              f.write('dir_changes_detected=true\n')
            print("ğŸŸ¢ Set dir_changes_detected=true")
          else:
            print("âŒ No paths match the specified filters")
            with open(os.getenv('GITHUB_ENV'), 'a') as f:
              f.write('dir_changes_detected=false\n')
            print("ğŸ”´ Set dir_changes_detected=false")

        if __name__ == "__main__":
          main()
        EOF

    - name: â¬ Download Modified Folders Only
      if: env.dir_changes_detected == 'true'
      id: download_changed_folders
      shell: bash
      run: |
        # Read all paths and download only the modified folders
        MODIFIED_FOLDERS=($(cat /tmp/paths.txt))
        echo "ğŸ“ Current modified directory: ${MODIFIED_FOLDERS[@]}"

        # Include 'scripts' in the list of directories to checkout
        MODIFIED_FOLDERS+=("scripts" ".utils")

        # Include 'utils' in the list of directories to checkout
        MODIFIED_FOLDERS+=(".utils")

        # Initialize git sparse-checkout
        git sparse-checkout init --cone

        # Set each path in MODIFIED_FOLDERS for sparse-checkout
        git sparse-checkout set "${MODIFIED_FOLDERS[@]}"

        # Checkout the latest changes
        git checkout
